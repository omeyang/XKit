// Code generated by MockGen. DO NOT EDIT.
// Source: pkg/distributed/xsemaphore/semaphore.go
//
// Generated by this command:
//
//	mockgen -source=pkg/distributed/xsemaphore/semaphore.go -destination=pkg/distributed/xsemaphore/xsemaphoremock/mock.go -package=xsemaphoremock -mock_names=Semaphore=MockSemaphore,Permit=MockPermit
//

// Package xsemaphoremock is a generated GoMock package.
package xsemaphoremock

import (
	context "context"
	reflect "reflect"
	time "time"

	xsemaphore "github.com/omeyang/xkit/pkg/distributed/xsemaphore"
	gomock "go.uber.org/mock/gomock"
)

// MockPermit is a mock of Permit interface.
type MockPermit struct {
	ctrl     *gomock.Controller
	recorder *MockPermitMockRecorder
	isgomock struct{}
}

// MockPermitMockRecorder is the mock recorder for MockPermit.
type MockPermitMockRecorder struct {
	mock *MockPermit
}

// NewMockPermit creates a new mock instance.
func NewMockPermit(ctrl *gomock.Controller) *MockPermit {
	mock := &MockPermit{ctrl: ctrl}
	mock.recorder = &MockPermitMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockPermit) EXPECT() *MockPermitMockRecorder {
	return m.recorder
}

// ExpiresAt mocks base method.
func (m *MockPermit) ExpiresAt() time.Time {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ExpiresAt")
	ret0, _ := ret[0].(time.Time)
	return ret0
}

// ExpiresAt indicates an expected call of ExpiresAt.
func (mr *MockPermitMockRecorder) ExpiresAt() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ExpiresAt", reflect.TypeOf((*MockPermit)(nil).ExpiresAt))
}

// Extend mocks base method.
func (m *MockPermit) Extend(ctx context.Context) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Extend", ctx)
	ret0, _ := ret[0].(error)
	return ret0
}

// Extend indicates an expected call of Extend.
func (mr *MockPermitMockRecorder) Extend(ctx any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Extend", reflect.TypeOf((*MockPermit)(nil).Extend), ctx)
}

// ID mocks base method.
func (m *MockPermit) ID() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ID")
	ret0, _ := ret[0].(string)
	return ret0
}

// ID indicates an expected call of ID.
func (mr *MockPermitMockRecorder) ID() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ID", reflect.TypeOf((*MockPermit)(nil).ID))
}

// Metadata mocks base method.
func (m *MockPermit) Metadata() map[string]string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Metadata")
	ret0, _ := ret[0].(map[string]string)
	return ret0
}

// Metadata indicates an expected call of Metadata.
func (mr *MockPermitMockRecorder) Metadata() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Metadata", reflect.TypeOf((*MockPermit)(nil).Metadata))
}

// Release mocks base method.
func (m *MockPermit) Release(ctx context.Context) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Release", ctx)
	ret0, _ := ret[0].(error)
	return ret0
}

// Release indicates an expected call of Release.
func (mr *MockPermitMockRecorder) Release(ctx any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Release", reflect.TypeOf((*MockPermit)(nil).Release), ctx)
}

// Resource mocks base method.
func (m *MockPermit) Resource() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Resource")
	ret0, _ := ret[0].(string)
	return ret0
}

// Resource indicates an expected call of Resource.
func (mr *MockPermitMockRecorder) Resource() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Resource", reflect.TypeOf((*MockPermit)(nil).Resource))
}

// StartAutoExtend mocks base method.
func (m *MockPermit) StartAutoExtend(interval time.Duration) func() {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "StartAutoExtend", interval)
	ret0, _ := ret[0].(func())
	return ret0
}

// StartAutoExtend indicates an expected call of StartAutoExtend.
func (mr *MockPermitMockRecorder) StartAutoExtend(interval any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "StartAutoExtend", reflect.TypeOf((*MockPermit)(nil).StartAutoExtend), interval)
}

// TenantID mocks base method.
func (m *MockPermit) TenantID() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "TenantID")
	ret0, _ := ret[0].(string)
	return ret0
}

// TenantID indicates an expected call of TenantID.
func (mr *MockPermitMockRecorder) TenantID() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TenantID", reflect.TypeOf((*MockPermit)(nil).TenantID))
}

// MockSemaphore is a mock of Semaphore interface.
type MockSemaphore struct {
	ctrl     *gomock.Controller
	recorder *MockSemaphoreMockRecorder
	isgomock struct{}
}

// MockSemaphoreMockRecorder is the mock recorder for MockSemaphore.
type MockSemaphoreMockRecorder struct {
	mock *MockSemaphore
}

// NewMockSemaphore creates a new mock instance.
func NewMockSemaphore(ctrl *gomock.Controller) *MockSemaphore {
	mock := &MockSemaphore{ctrl: ctrl}
	mock.recorder = &MockSemaphoreMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockSemaphore) EXPECT() *MockSemaphoreMockRecorder {
	return m.recorder
}

// Acquire mocks base method.
func (m *MockSemaphore) Acquire(ctx context.Context, resource string, opts ...xsemaphore.AcquireOption) (xsemaphore.Permit, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, resource}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Acquire", varargs...)
	ret0, _ := ret[0].(xsemaphore.Permit)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Acquire indicates an expected call of Acquire.
func (mr *MockSemaphoreMockRecorder) Acquire(ctx, resource any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, resource}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Acquire", reflect.TypeOf((*MockSemaphore)(nil).Acquire), varargs...)
}

// Close mocks base method.
func (m *MockSemaphore) Close(ctx context.Context) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Close", ctx)
	ret0, _ := ret[0].(error)
	return ret0
}

// Close indicates an expected call of Close.
func (mr *MockSemaphoreMockRecorder) Close(ctx any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockSemaphore)(nil).Close), ctx)
}

// Health mocks base method.
func (m *MockSemaphore) Health(ctx context.Context) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Health", ctx)
	ret0, _ := ret[0].(error)
	return ret0
}

// Health indicates an expected call of Health.
func (mr *MockSemaphoreMockRecorder) Health(ctx any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Health", reflect.TypeOf((*MockSemaphore)(nil).Health), ctx)
}

// Query mocks base method.
func (m *MockSemaphore) Query(ctx context.Context, resource string, opts ...xsemaphore.QueryOption) (*xsemaphore.ResourceInfo, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, resource}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Query", varargs...)
	ret0, _ := ret[0].(*xsemaphore.ResourceInfo)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Query indicates an expected call of Query.
func (mr *MockSemaphoreMockRecorder) Query(ctx, resource any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, resource}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Query", reflect.TypeOf((*MockSemaphore)(nil).Query), varargs...)
}

// TryAcquire mocks base method.
func (m *MockSemaphore) TryAcquire(ctx context.Context, resource string, opts ...xsemaphore.AcquireOption) (xsemaphore.Permit, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, resource}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "TryAcquire", varargs...)
	ret0, _ := ret[0].(xsemaphore.Permit)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// TryAcquire indicates an expected call of TryAcquire.
func (mr *MockSemaphoreMockRecorder) TryAcquire(ctx, resource any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, resource}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TryAcquire", reflect.TypeOf((*MockSemaphore)(nil).TryAcquire), varargs...)
}
